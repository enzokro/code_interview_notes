
def flippingBits(n):
    '''Nice way vs casting to string.
    '''
    # return ~n & 0xffffffff # flip all bits, then handle 2-s complement for unsigned
    return n ^ 0xffffffff # directly with xor
    # num = f"{n:032b}"
    # res = []
    # for i in range(32):
    #     res.append('1' if num[i] == '0' else '0')
    # return int(''.join(res), 2)


'''
You are given an array of integers a. A new array b is generated by rearranging the elements of a in the following way:

b[0] is equal to a[0];
b[1] is equal to the last element of a;
b[2] is equal to a[1];
b[3] is equal to the second-last element of a;
b[4] is equal to a[2];
b[5] is equal to the third-last element of a;
and so on.
Your task is to determine whether the new array b is sorted in strictly ascending order or not.

Here is how the process of generating the new array b works:
'''
from collections import deque
def solution(a):
    
    b = []
    
    b.append(a[0])
    
    rem = deque(a[1:])
    while rem:
        b.append(rem.pop())
        if rem:
            b.append(rem.popleft())
                 
        
    for i in range(1, len(a)):
        if b[i] <= b[i-1]:
            return False
            
    return True

'''
You are given an array of integers a, where each element a[i] represents the length of a ribbon.

Your goal is to obtain k ribbons of the same length, by cutting the ribbons into as many pieces as you want.

Your task is to calculate the maximum integer length L for which it is possible to obtain at least k ribbons of length L by cutting the given ones.
'''
def solution(a, k):

    '''Optimized binary search
    '''
    # return max_cut
    a.sort(reverse=True)
    lo, hi = 1, max(a)
    
    while lo <= hi:
        
        mid = lo + (hi - lo) // 2
        cuts = 0
        for rib in a:
            cuts += rib // mid
            if cuts >= k:
                lo = mid + 1
                break
        if lo != mid + 1:
            hi = mid - 1
            
    return hi


'''
An integer n is called a full square, if there exists some integer s, such that n = s * s. Examples of full squares are 0, 1, 4, 9, 16, etc.

Given an array of distinct integers numbers, your task is to find the number of pairs of indices (i, j) such that i ≤ j and the sum numbers[i] + numbers[j] is a full square.
'''
def solution(numbers):
    
    # store all perfect squares
    perf_sqr = set()
    max_val = int(2 * 10e4)
    for i in range(max_val):
        cand = i * i
        if cand <= max_val:
            perf_sqr.add(cand)
        else:
            break
            
        
    # brute force
    ways = 0
    for i,n1 in enumerate(numbers): 
        for j,n2 in enumerate(numbers):
            if (n1 + n2) in perf_sqr and i <= j:
                ways += 1
                
    return ways

    

'''
Given two strings s and t, both consisting of lowercase English letters and digits, your task is to calculate how many ways exactly one digit could be removed from one of the strings so that s is lexicographically smaller than t after the removal. Note that we are removing only a single instance of a single digit, rather than all instances (eg: removing 1 from the string a11b1c could result in a1b1c or a11bc, but not abc).

Also note that digits are considered lexicographically smaller than letters.
'''
def solution(s, t):
    
    digits = [d for d in '0123456789']
    def is_digit(o):
        return o in digits
        
    def remove_from(string, idx):
        rem = string[:idx] + string[idx+1:]
        return rem
        
    ways = 0
    
    for i,c in enumerate(s):
        if is_digit(c):
            if remove_from(s, i) < t:
                ways += 1
                
    for i,c in enumerate(t):
        if is_digit(c):
            if s < remove_from(t, i):
                ways += 1
                
    return ways    
    

    ## greedy approach with linear search and early stopping
    def cut_ribbon(rlen, cut):
        return rlen // cut
    max_cut = cut = 1
    while True:
        cnt = 0
        for n in a:
            cnt += cut_ribbon(n, cut)
            if cnt >= k:
                max_cut = max(max_cut, cut)
                cut += 1
                break
        if cnt < k:
            break
    
    return max_cut

def diagonalDifference(arr):
    # indexes we will use for the diagonal and anti-diagonal
    diag_inds = range(len(arr))

    # find sum of diagonal
    diag_sum = sum(arr[i][i] for i in diag_inds)
    
    # use ~i notation to grab the anti-diagonal
    anti_diag_sum = sum(arr[i][~i] for i in diag_inds)

    # return their absolute difference
    return abs(diag_sum - anti_diag_sum)


def countingSort(arr):
    # frequency counter
    res = [0] * 100
    for n in arr:
        res[n] += 1
    return res
    # to build the sorted output array, would then be
    sorted_out = []
    for idx,r in enumerate(res):
        if r:
            sorted_out.extend([idx] * r)


def pangrams(s):
    '''Checking upper and lower case characters without string magic.

    ord() makes things platform/encoding agnostic
    '''
    chars = list(range(ord('a'), ord('z')))
    upper_lower_diff = ord('a') - ord('A')
    cmap = set(chars)
    for c in filter(lambda o: o, s):
        val = ord(c)
        if val < ord('a'):
            val += upper_lower_diff
        if val in cmap:
            cmap.remove(val)
    return 'not pangram' if cmap else 'pangram'


def sumTwoArrayPermsAboveK(k, A, B):
    '''Check if we can permute A/B so every pairwise elems sum to >= k
    
    Insight comes from needing to be >=k
    Then, we can sort the arrays
        If the largest/smallest running element cannot sum above k, then no other pair will
    '''
    # Write your code here
    A.sort(), B.sort()
    
    can_sum = True
    for i in range(len(A)):
        if A[i] + B[~i] < k:
            can_sum = False
            break
        
    return 'YES' if can_sum else 'NO'





def birthday(s, d, m):
    '''
    Two children, Lily and Ron, want to share a chocolate bar. Each of the squares has an integer on it.

    Lily decides to share a contiguous segment of the bar selected such that:

    The length of the segment matches Ron's birth month, and,
    The sum of the integers on the squares is equal to his birth day.
    Determine how many ways she can divide the chocolate.
    '''
    nways = 0
    # NOTE: trick was here, have to go from [0 ... len(s)) 
    # will go from 0 to len(s) - 1
    # if we take away m, then we'll go
    # len(s) - 1 - m
    # but, m is inclusive, we have to add one back in since we're counting spots
    for i in range(0, len(s) - m + 1):
        if sum(s[i:i+m]) == d:
            nways += 1

    # alternative without for loop
    i = 0
    while i < len(s) - m + 1:
        if sum(s[i:i+m]) == d:
            nways += 1
        i += 1
    return nways


def strings_xor(s, t):
    res = ""
    for i in range(len(s)):
        if s[i] == t[i]:
            res += '0';
        else:
            res += '1';

    return res

    s = input()
    t = input()
    print(strings_xor(s, t))


def flippingMatrix(matrix):
    max_total = 0
    two_n = len(matrix)
    n = two_n // 2
    
    for i in range(n):
        for j in range(n):
            max_s = max(matrix[i][j], matrix[i][(two_n-1)-j], matrix[(two_n-1)-i][j], matrix[(two_n-1)-i][(two_n-1)-j])
            max_total += max_s
    
    return max_total


def sockMerchant(n, ar):
    '''
    There is a large pile of socks that must be paired by color. Given an array of integers representing the color of each sock, determine how many pairs of socks with matching colors there are.
    
    Example
        There is one pair of color 1 and one of color 2. There are three odd socks left, one of each color. The number of pairs is .
    '''
    # build count map of the socks
    colors = {}
    for c in ar:
        colors[c] = 1 + colors.get(c, 0)
    
    # count the number of pairs
    num_pairs = 0
    for _,num in colors.items():
        while num >= 2:
            num_pairs += 1
            num -= 2
    
    return num_pairs


def findZigZagSequence(a, n):
    a.sort()
    mid = int((n)/2) # zone one: let python integer handle the midpoint. 
    a[mid], a[n-1] = a[n-1], a[mid]

    st = mid + 1
    ed = n - 2 # we already swapped the last element, will be "smallest" relative to rest of eleems
    while(st <= ed):
        a[st], a[ed] = a[ed], a[st]
        st = st + 1
        ed = ed - 1 # make sure we are decrementing the value

    for i in range (n):
        if i == n-1:
            print(a[i])
        else:
            print(a[i], end = ' ')
    return

    test_cases = int(input())
    for cs in range (test_cases):
        n = int(input())
        a = list(map(int, input().split()))
        findZigZagSequence(a, n)

def pageCount(n, p):
    # Write your code here
    return min(p//2, n//2 - p//2)


def towerBreakers(n, m):
    # the optimal move is always to take down a tower to 1
    # if the tower height is one, player1 can't move.
    # if there are an even number of towers, p2 can always mimic p1, and eventually will take optimal move and leave him with 1 tower
    return 2 if (m==1 or n % 2 == 0) else 1


def caesarCipher(s, k):
    # Write your code here
    
    # CRITICAL POINT HERE
    # k could have been larger than 26, we'd have to map the loop around
    # the logic of % ord(z | Z) fails when k > n * 26 where n >= 1
    k %= 26
    
    def encode(c):
        val = ord(c)
        
        # lower case letter
        if ord('a') <= val <= ord('z'):
            new_val = val + k
            
            # if we overshoot, find the new mapping
            if new_val > ord('z'):
                rem = new_val % ord('z')
                new_val = ord('a') - 1 + rem
                
        # same handling for uppercase
        elif ord('A') <= val <= ord('Z'):
            new_val = val + k
            if new_val > ord('Z'):
                rem = new_val % ord('Z')
                new_val = ord('A') - 1 + rem

        # this is a non-character, return as is
        else:
            return c
            
        return chr(new_val)
    
    return ''.join(encode(o) for o in s)



def maxMin(k, arr):
    '''
    NOTE: did not think of extreme values or outliers.

    Assumed all values would be small and nice behaved integers. But! Look at inputs, data could be huge.

    Insight came from seeing that numbers might be something like:
        [0, 1, 12345, 12346, 12347]

    If we take the first part of the array, the unfairness will be huge.
        We actually need the last three elements, where the unfairness will be 2
    Sorting guarantess our sliding window will have the smallest elements.
        But! It has to go through the whole list of candidates. 

    Takeaways:
        Look at inputs, think about what the ranges mean
        Consider wild inputs, edge cases.

    Should know this by now...
    '''
    # Write your code here
    arr.sort()
    ans = float("inf")
    for i in range(len(arr) - k + 1):
        ans = min(ans, arr[i+k-1] - arr[i])
    return ans


def gridChallenge(grid):
    # Write your code here
    
    # grab grid dimensions for convenience
    nrows, ncols = len(grid), len(grid[0])
    
    def is_sorted(col):
        """Helper to check if an array / string is sorted"""
        for i in range(len(col) - 1):
            if col[i] > col[i+1]:
                return False
        return True
    
    # sort the rows if needed
    grid = [sorted(row) if (not is_sorted(row)) else row for row in grid]
    
    # check if the columns are sorted
    for col in range(ncols):
        cur_col = [grid[row][col] for row in range(nrows)]
        if not is_sorted(cur_col):
            return "NO"
        
    return "YES"



def balancedSums(arr):
    if len(arr) == 1:
        return 'YES'
    
    run_sum = 0
    inv_sum = 0
    sum_prod = []
    inv_sum_prod = []
    
    # build the forward sum
    for i in range(len(arr)):
        run_sum += arr[i]
        sum_prod.append(run_sum)
        # build the backward sum as well
        inv_sum += arr[~i]
        inv_sum_prod.append(inv_sum)
    
    # NOTE: could use left append on a queue too
    inv_sum_prod = inv_sum_prod[::-1]

    # edge cases, were independent of the array, can check the values directly
    if inv_sum_prod[1] == 0 or sum_prod[-2] == 0:
        return 'YES'

    # check the other indexes    
    for i in range(len(arr)-2):
        if sum_prod[i] == inv_sum_prod[i+2]:
            return 'YES'
    
    # Write your code here
    return 'NO'



def MinesweeperBFS(field, x, y):
    
    nrows = len(field)
    ncols = len(field[0])
    
    num_mines = [[-1] * ncols for _ in range(nrows)]
        
    # keep track of nodes we already visited
    visited = set()
    
    # bfs, with dequeue as auxiliary DS
    def bfs(r, c):
        
        # will visit all neighbors of (r,c)
        q = collections.deque()
        
        # mark this node as visited, and put it on the queue to start iterating
        visited.add((r,c))
        q.append((r,c))
        
        # keep going while we have un-visited neighbors
        while q:
            
            # grab current node
            # NOTE: this is where we could change to a DFS, by using pop() instead of popleft()
            #       That way, we visit the most recent node instead of the first.
            row, col = q.popleft()
            
            # check all of its neighbors
            row_inds = [-1,-1,-1,0,1,1,1,0]
            col_inds = [-1,0,1,1,1,0,-1,-1]
            nmines = 0
            candidates = []
            for (dr, dc) in zip(row_inds, col_inds):
                
                # neighbor cell to visit
                r = row + dr
                c = col + dc 
                
                # make sure we are in bounds
                if (0 <= r < nrows) and (0 <= c < ncols):
                    
                    # count the number of mines
                    if field[r][c]:
                        nmines += 1
                        
                    # add the current, potential candidate
                    candidates.append((r,c))
                    
            # mark the number of mines on the clicked spot
            num_mines[row][col] = nmines

            # if there were no mines, visit the others
            if nmines == 0:
                for (r,c) in candidates:
                    if (r,c) not in visited:
                        q.append((r,c))
                        visited.add((r,c))
    
    # iterate through each cell
    bfs(x, y)
    
    return num_mines


def solution(a):
    
    ap = [0] + a + [0]
    b = []
    for i in range(1, len(a)+1): 
        r = ap[i-1] + ap[i] + ap[i+1]
        b.append(r)
    return b 


def divisibleSumPairs(n, k, ar):
    # Write your code here
    
    divs = {}
    for a in ar:
        d = a % k
        divs[d] = 1 + divs.get(d, 0)
        
    # count up the possible pairs
    tot = 0
    
    if 0 in divs:
        tot += (divs[0] * (divs[0] - 1)) / 2
        
    j = 1
    while j <= k // 2 and j != (k - j):
        if j in divs and k - j in divs:
            tot +=  divs[j] * divs[k - j]
        j += 1
            
    # special care for even k (why?)
    # If K is even
    if( k % 2 == 0 ):
        if k // 2 in divs:
            tot += (divs[k//2] * (divs[k//2]-1)/2);
        
    return int(tot)

    from collections import defaultdict
    buckets = defaultdict(int)
    tot = 0
    for a in ar:
        div = a % k
        tot += buckets.get((k - div) % k, 0)
        buckets[div] += 1
    return tot



'''
Let's say a triple (a, b, c) is a zigzag if either a < b > c or a > b < c.

Given an array of integers numbers, your task is to check all the triples of its consecutive elements for being a zigzag. More formally, your task is to construct an array of length numbers.length - 2, where the ith element of the output array equals 1 if the triple (numbers[i], numbers[i + 1], numbers[i + 2]) is a zigzag, and 0 otherwise.
'''
def solution(numbers):
    k = 3
    zig = [0] * (len(numbers) - k + 1)
    for i in range(0, len(numbers) - k + 1):
        l, r = i+1, i+2
        if (numbers[i] < numbers[l] > numbers[r]) or (numbers[i] > numbers[l] < numbers[r]):
            zig[i] = 1
    return zig


'''
You are given a string s. Your task is to count the number of ways of splitting s into three non-empty parts a, b and c (s = a + b + c) in such a way that a + b, b + c and c + a are all different strings.

NOTE: + refers to string concatenation.
'''
def solution(s):
    cnt = 0
    n = len(s)
    for i in range(1, n - 1):
        for j in range(i+1, n):
            a = s[:i]
            b = s[i:j]
            c = s[j:]
            if (a + b) != (b + c) and (b+c) != (c+a) and (a+b) != (c+a):
                cnt += 1
    return cnt



'''
You've created a new programming language, and now you've decided to add hashmap support to it. Actually you are quite disappointed that in common programming languages it's impossible to add a number to all hashmap keys, or all its values. So you've decided to take matters into your own hands and implement your own hashmap in your new language that has the following operations:

insert x y - insert an object with key x and value y.
get x - return the value of an object with key x.
addToKey x - add x to all keys in map.
addToValue y - add y to all values in map.
To test out your new hashmap, you have a list of queries in the form of two arrays: queryTypes contains the names of the methods to be called (eg: insert, get, etc), and queries contains the arguments for those methods (the x and y values).

Your task is to implement this hashmap, apply the given queries, and to find the sum of all the results for get operations.
'''
def solution(queryType, query):
    ans = 0
    hmap = {}
    ck = 0
    cv = 0
    for i in range(len(queryType)):
        cmd = queryType[i]
        quer = query[i]
        if cmd == "insert":
            key,val = quer[0],quer[1]
            hmap[key-ck]=val-cv
        elif cmd == "addToValue":
            k = quer[0]
            cv+=k
        elif cmd == "addToKey":
            k = quer[0]
            ck+=k
        else:
            k = quer[0]
            k-=ck
            val = hmap[k] + cv
            ans = ans + val
    return ans



'''
You are given a string s. Consider the following algorithm applied to this string:

Take all the prefixes of the string, and choose the longest palindrome between them.
If this chosen prefix contains at least two characters, cut this prefix from s and go back to the first step with the updated string. Otherwise, end the algorithm with the current string s as a result.
Your task is to implement the above algorithm and return its result when applied to string s.

Note: you can click on the prefixes and palindrome words to see the definition of the terms if you're not familiar with them.
'''
def solution(s):
    
    def prefixPalindromeHelper(s, start, end):
        if start == end:
            return ''
        # start from end to find the longest palindromic prefix
        for e in range(end, start + 1, -1):
            if s[start:e] == s[start:e][::-1]:
                return prefixPalindromeHelper(s, e, end)
        return s[start:]
        
        
    return prefixPalindromeHelper(s, 0, len(s))






'''Finding the count of all index pairs that sum to powers of two.

Can go to fixed range thanks to bounds in the problem.

Clever use of hashset, and hashmap if we care about uniqueness

Going in reverse avoids the need to track the idxs'''
def solution(numbers):

    # stores the count of valid pairs
    count = 0
    
    # computes the target powers of two using bit shifts
    targets = [1] + [1 << i for i in range(1,31)]
    
    # keeps track of values we've seen so far. used to search for target complements
    seen = set()

    # step through the numbers once, in reverse
    for n in numbers[::-1]:
        # add the current number to the hashset
        seen.add(n)

        # finds the count of valid pairs in one go with a generator
        count += sum(t - n in seen for t in targets)
        
        # # scan through all potential targets
        # for t in targets:
        #     # if this complement is in the map, it means we've found a valid pair
        #     if (t - n) in seen:
        #         count += 1


                    
    return count


'''
Given an array of integers a, your task is to find how many of its contiguous subarrays of length m contain a pair of integers with a sum equal to k.

More formally, given the array a, your task is to count the number of indices 0 ≤ i ≤ a.length - m such that a subarray [a[i], a[i + 1], ..., a[i + m - 1]] contains at least one pair (a[s], a[t]), where:

s ≠ t
a[s] + a[t] = k
'''
from collections import deque

def solution(a, m, k):
    
    window = deque([])
    
    def two_sum(win):
        seen = set()
        for n in win:
            if k - n in seen:
                return True
            seen.add(n)
        return False
    
    cnts = 0
    for i in range(0, len(a)):
        
        # grow the window till we have enough elements
        if i < m:
            window.append(a[i])
            
        else:
            # check the current window once we have enough elements
            cnts += int(two_sum(window))
            # remove the previous element
            window.popleft()
            # append the current one
            window.append(a[i])    
    
    # check the final window   
    cnts += int(two_sum(window))
            
    return cnts


def solution(a, m, k):
    
    # stores the total count of valid sub-arrays
    count = 0

    # map to lookup the last observed index of an element
    last_pos = {} 

    # flag check whether a complement is within the "k" window
    max_complement_pos = -1
    
    # step through the entire array
    for head, num in enumerate(a, 1):
    
        # find the tail of the current window
        tail = head - m
        
        # if our tail has gone past the first element of the array (tail > 0)...
        # And, if the index of the last element was *at or before* the tail...
        # that means it's time to drop the last element.
        if 0 < last_pos[a[tail]] <= tail: 
            del last_pos[a[tail]]
        
        # find the largest index for the complement of the current element, if it exists
        max_complement_pos = max(max_complement_pos, last_pos.get(k - num, -1))
        
        # if we have at least "m" elements in the sub-array...
        if head >= m:
            # check if the valid complement happened inside the window 
            count += max_complement_pos > tail

        ## can write the above in a single loop
        # count += head >= m and max_complement_pos > tail
        
        # mark the current element with the head index
        last_pos[num] = head 
        
    return count